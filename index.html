<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flight Rising Gathering & Item Parser</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    background-color: #fafafa;
    color: #222;
    margin: 0;
    padding: 20px;
  }
  h1, h2 {
    text-align: center;
  }
  textarea {
    width: 100%;
    height: 250px;
    font-family: monospace;
    font-size: 14px;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #ccc;
    box-sizing: border-box;
  }
  button {
    display: block;
    margin: 20px auto;
    padding: 10px 20px;
    font-size: 16px;
    border-radius: 6px;
    border: none;
    background: #007acc;
    color: #fff;
    cursor: pointer;
  }
  button:hover {
    background: #005fa3;
  }
  .tab-buttons {
    text-align: center;
    margin-bottom: 20px;
  }
  .tab-buttons button {
    margin: 0 5px;
    background: #ccc;
  }
  .tab-buttons button.active {
    background: #007acc;
    color: white;
  }
  .results {
    margin-top: 20px;
  }
  .category {
    margin-top: 30px;
    padding: 10px;
    border-left: 4px solid #007acc;
    background: #f0f8ff;
  }
  .category h2 {
    margin-top: 0;
  }
  .item-list {
    margin-left: 20px;
  }
</style>
</head>
<body>
<h1>Flight Rising Gathering & Item Parser</h1>

<div class="tab-buttons">
  <button id="gatherTab" class="active">Gathering Parser</button>
  <button id="itemTab">Item Page Parser</button>
</div>

<!-- Gathering Parser -->
<div id="gatheringPage">
  <p>Paste the wiki source text below and click “Extract Items”.</p>
  <textarea id="inputText" placeholder="Paste Flight Rising gathering source here..."></textarea>
  <button id="extractBtn">Extract Items</button>
  <div id="output" class="results"></div>
</div>

<!-- Item Page Parser -->
<div id="itemPage" style="display:none;">
  <p>Navigate to a wiki page of the fandom wiki. (IE: <a href="https://flightrising.fandom.com/wiki/Rusty_Pickaxe" target="_blank">Rusty Pickaxe</a>, type CTRL + A, then paste the full text below and click “Parse Item”.</p>
  <textarea id="itemText" placeholder="Paste entire wiki item page text here..."></textarea>
  <button id="parseItemBtn">Parse Item Page</button>
  <div id="itemOutput" class="results"></div>
</div>

<script>
// ===== TAB SWITCHING =====
document.getElementById('gatherTab').onclick = () => {
  document.getElementById('gatheringPage').style.display = 'block';
  document.getElementById('itemPage').style.display = 'none';
  document.getElementById('gatherTab').classList.add('active');
  document.getElementById('itemTab').classList.remove('active');
};
document.getElementById('itemTab').onclick = () => {
  document.getElementById('gatheringPage').style.display = 'none';
  document.getElementById('itemPage').style.display = 'block';
  document.getElementById('itemTab').classList.add('active');
  document.getElementById('gatherTab').classList.remove('active');
};

// ===== GATHERING PARSER =====
document.getElementById('extractBtn').addEventListener('click', () => {
  const text = document.getElementById('inputText').value;
  const outputDiv = document.getElementById('output');
  outputDiv.innerHTML = '';

  const sectionRegex = /==\s*([A-Za-z ]+)\s*==([\s\S]*?)(?=(?:==|$))/g;
  const data = {};
  let sectionMatch;

  while ((sectionMatch = sectionRegex.exec(text)) !== null) {
    const category = sectionMatch[1].trim();
    const sectionContent = sectionMatch[2];
    const levelRegex = /(?:'''[\w\s]+'''[^\n]*\n)?\s*Level\s*(\d+):([\s\S]*?)(?=(?:Level\s*\d+:|$))/g;
    let levelMatch;
    const items = [];

    while ((levelMatch = levelRegex.exec(sectionContent)) !== null) {
      const level = levelMatch[1].trim();
      const levelContent = levelMatch[2];
      const itemRegex = /[\w\s'()!-]+\.png\|\[\[([^\]]+)\]\]\s*[-–]\s*([A-Za-z, ]+)/g;
      let itemMatch;
      while ((itemMatch = itemRegex.exec(levelContent)) !== null) {
        items.push(`${itemMatch[1]} - ${itemMatch[2]} (Level ${level})`);
      }
    }
    if (items.length > 0) data[category] = items;
  }

  if (Object.keys(data).length === 0) {
    outputDiv.innerHTML = '<p><em>No items found.</em></p>';
    return;
  }

  for (const [category, items] of Object.entries(data)) {
    const section = document.createElement('div');
    section.className = 'category';
    section.innerHTML = `<h2>${category}</h2>`;
    const list = document.createElement('ul');
    list.className = 'item-list';
    items.forEach(item => {
      const li = document.createElement('li');
      li.textContent = item;
      list.appendChild(li);
    });
    section.appendChild(list);
    outputDiv.appendChild(section);
  }
});

// ===== ITEM PAGE PARSER =====
document.getElementById('parseItemBtn').addEventListener('click', () => {
  const text = document.getElementById('itemText').value;
  const output = document.getElementById('itemOutput');
  output.innerHTML = '';

  // Identify item name (line after "Edit")
  const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
  let itemName = "Unknown Item";
  for (let i = 0; i < lines.length; i++) {
    if (/^Edit$/i.test(lines[i]) && lines[i + 1]) {
      const candidate = lines[i + 1].trim();
      if (candidate && /^[A-Z][A-Za-z' -]+$/.test(candidate)) {
        itemName = candidate;
        break;
      }
    }
  }

  // Extract section between headers
  const extractSection = (start, stop) => {
    const regex = new RegExp(`(?:^|\\n)${start}[\\s\\S]*?(?=(?:^|\\n)(?:${stop})(?:\\n|$))`, "i");
    const match = text.match(regex);
    if (!match) return null;
    return match[0].replace(new RegExp(`(?:^|\\n)${start}`, "i"), "").trim();
  };

  // Allow "Usage" or "Uses" headers
const usage = extractSection("(?:Usage|Uses)", "Trivia|History|See Also|References");
  if (!usage) {
    output.innerHTML = `<p><em>No usage found.</em></p>`;
    return;
  }

  // Identify category based on keywords
  let category = "Other";
  let itemDetail = "";

  const linesFiltered = usage.split('\n').map(l => l.trim()).filter(Boolean);

  // Detect all relevant categories regardless of order
  const foundCategories = [];

  for (let i = 0; i < linesFiltered.length; i++) {
    const line = linesFiltered[i];

    // Hibernal Den detection
    if (/Hibernal Den/i.test(line)) {
      const match = line.match(/Hibernal Den:\s*(.*)/i);
      if (match) {
        foundCategories.push({
          category: "Hibernal Den",
          detail: match[1].trim()
        });
      }
    }

    // Swipp’s Swap Stand detection
    if (/Swipp'?s Swap Stand/i.test(line)) {
      // Collect recipe lines following Swipp
      let recipeLines = [];
      for (let j = i + 1; j < linesFiltered.length; j++) {
        // Stop when hitting a new header or unrelated line
        if (/^(Baldwin|Food|Hibernal Den|Bonding|Trivia|History|See Also|References)/i.test(linesFiltered[j])) break;
        if (/^\s{2,}|\([0-9]+/.test(linesFiltered[j]) || /^[A-Z]/.test(linesFiltered[j])) {
          recipeLines.push(linesFiltered[j]);
        }
      }

      // If we have recipe details, use only that
      if (recipeLines.length > 0) {
        const recipeText = recipeLines.join(' ').trim();
        foundCategories.push({
          category: "Swipp Trades",
          detail: `part of the required items for a Swipp trade: ${recipeText}`
        });
      }
      // If not, capture the single-line version only once
      else if (!/part of the required items for a Swipp trade:$/i.test(line)) {
        const match = line.match(/Swipp'?s Swap Stand:?\s*(.*)/i);
        if (match && match[1]) {
          foundCategories.push({
            category: "Swipp Trades",
            detail: `part of the required items for a Swipp trade: ${match[1].trim()}`
          });
        }
      }
    }



    // Baldwin detection
if (/Baldwin/i.test(line)) {
  const match = line.match(/Baldwin'?s Bubbling Brew:?\s*(.*)/i);
  let detail = match && match[1] ? match[1].trim() : "";

  // Collect recipe lines following the Baldwin line
  let recipeLines = [];
  for (let j = i + 1; j < linesFiltered.length; j++) {
    if (/^(Swipp|Hibernal Den|Sophie|Food|Bonding|Trivia|History|See Also|References)/i.test(linesFiltered[j])) break;
    if (/^\s{2,}|\([0-9]+/.test(linesFiltered[j]) || /^[A-Z]/.test(linesFiltered[j])) {
      recipeLines.push(linesFiltered[j]);
    }
  }

  const recipeText = recipeLines.join(' ').trim();

  // Skip if Baldwin line is only random-color transmutation with no other purpose
  if (/(random color of|melted down)/i.test(detail) && !/recipe|required|create|ingredient|used/i.test(detail) && !recipeText) {
    continue;
  }


  // If recipe text exists, build structured output
  if (recipeText) {
    // Merge any descriptive text before the recipe
    if (/recipe|required|create|ingredient|used/i.test(detail)) {
      detail = `${detail.replace(/can be transmuted into a random color of[^,]*,?\s*/i, '').trim()} ${recipeText}`.trim();
    } else {
      detail = `used in a Baldwin recipe: ${recipeText}`;
    }
  }

  // Catch fallback cases where no recipe lines but text still relevant
  if (!recipeText && /Baldwin/i.test(detail)) {
    detail = detail.replace(/can be transmuted into a random color of[^,]*,?\s*/i, '').trim();
  }

  if (detail) {
    foundCategories.push({
      category: "Baldwin",
      detail: detail
    });
  }
}




  // Sophie's Splendid Stitches detection
  if (/Sophie'?s Splendid Stitches/i.test(line)) {
    // Collect recipe lines following Sophie's entry
    let recipeLines = [];
    for (let j = i + 1; j < linesFiltered.length; j++) {
      // Stop when hitting another header or unrelated line
      if (/^(Baldwin|Swipp|Hibernal Den|Food|Bonding|Trivia|History|See Also|References)/i.test(linesFiltered[j])) break;
      if (/^\s{2,}|\([0-9]+/.test(linesFiltered[j]) || /^[A-Z]/.test(linesFiltered[j])) {
        recipeLines.push(linesFiltered[j]);
      }
    }

    const recipeText = recipeLines.join(' ').trim();
    const match = line.match(/Sophie'?s Splendid Stitches:?\s*(.*)/i);
    let detail = "";

    // If recipe lines exist, use them
    if (recipeText) {
      detail = `${match && match[1] ? match[1].trim() + ' ' : ''}${recipeText}`.trim();
    }
    // Otherwise, fallback to single-line info
    else if (match && match[1]) {
      detail = match[1].trim();
    }

    if (detail) {
      foundCategories.push({
        category: "Sophie's Splendid Stitches",
        detail: detail
      });
    }
  }
}





// Clean unnecessary lines
const cleanUsage = linesFiltered
  .map(line => line.trim())                                   // Trim spaces/tabs
  .filter(line => line.length > 0)
  .filter(line => !/^Food:/i.test(line))                      // Remove Food lines
  .filter(line => !/^Trivia/i.test(line))                     // Remove Trivia header
  .filter(line => !/^Monster\b/i.test(line))                  // Remove any line starting with "Monster"
  .filter(line => !/^Baldwin'?s Bubbling Brew/i.test(line))   // Remove Baldwin base line
  .filter(line => !/^Swipp'?s Swap Stand/i.test(line))        // Remove Swipp base line
  .filter(line => !/^This item|^They'?re|^Satin/i.test(line)) // Remove trivia fluff
  .join('<br>');



  // Load or create stored data
  const storedData = JSON.parse(localStorage.getItem('frCategories') || '{}');
  if (!storedData[category]) storedData[category] = [];

  // Display the current parsed item result
const currentSection = document.createElement('div');
currentSection.className = 'category';
currentSection.innerHTML = `<h2>Current Parse</h2>`;
const currentList = document.createElement('ul');
currentList.className = 'item-list';

// If a valid recipe (Swipp, Baldwin, or Hibernal Den) was found, display that
if (foundCategories.length > 0) {
  foundCategories.forEach(entryObj => {
    const { category, detail } = entryObj;
    const entry = `${itemName} | ${detail}`;
    const li = document.createElement('li');
    li.textContent = entry;
    currentList.appendChild(li);

    if (!storedData[category]) storedData[category] = [];
    if (!storedData[category].includes(entry)) {
      storedData[category].push(entry);
    }
  });
  localStorage.setItem('frCategories', JSON.stringify(storedData));
} else {
  // Otherwise, show the parsed name and basic usage
  const li = document.createElement('li');
  li.innerHTML = `<strong>${itemName}</strong><br>${cleanUsage || '<em>No special recipe detected.</em>'}`;
  currentList.appendChild(li);
}


currentSection.appendChild(currentList);
output.appendChild(currentSection);

// Render all saved categories below
const savedTitle = document.createElement('h2');
savedTitle.textContent = 'Saved Categories';
output.appendChild(savedTitle);

Object.entries(storedData).forEach(([cat, items]) => {
  const section = document.createElement('div');
  section.className = 'category';
  section.innerHTML = `<h2>${cat}</h2><ul class="item-list"></ul>`;
  const ul = section.querySelector('ul');
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    ul.appendChild(li);
  });
  section.appendChild(ul);
  output.appendChild(section);
});


  // Add clear storage button
  const clearBtn = document.createElement('button');
  clearBtn.textContent = 'Clear Saved Data';
  clearBtn.style.display = 'block';
  clearBtn.style.margin = '20px auto';
  clearBtn.onclick = () => {
    localStorage.removeItem('frCategories');
    output.innerHTML = '<p><em>Storage cleared.</em></p>';
  };
  output.appendChild(clearBtn);
});

</script>

</body>
</html>
